import{aQ as D,aR as d,V as u,aj as x,a8 as h,aS as Y,aT as B,a4 as I,aU as b,R as V}from"./sceneFragmentDeclaration-CNWtVIbJ.js";import{B as y}from"./model-viewer-CRf71ZHW.js";import"./with-props-CdbLO-WJ.js";import"./chunk-AYJ5UCUI-B1579ApN.js";import"./waterMaterial-DHEJP-Do.js";const F="Xposition",O="Yposition",A="Zposition",k="Xrotation",L="Yrotation",P="Zrotation",j="HIERARCHY",X="MOTION";class z{constructor(i){this.loopMode=d.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=S(),this.numFrames=0,this.frameRate=0,this.skeleton=i}}function S(){return{name:"",type:"",offset:new u,channels:[],children:[],frames:[],parent:null}}function K(){return{time:0,position:new u,rotation:new I}}function Z(r){const i=r.offset.x,s=r.offset.y,o=-r.offset.z;return h.Translation(i,s,o)}function Q(r,i){if(r.frames.length===0)return null;const s=[],o=r.channels.some(e=>e===F||e===O||e===A),t=r.channels.some(e=>e===k||e===L||e===P);for(let e=0;e<r.frames.length;e++){const c=r.frames[e],m=e*i.frameRate*1e3;if(o||t){let l=h.Identity();if(t){const f=new h;c.rotation.toRotationMatrix(f),l=f}if(o){const f=c.position;l.setTranslation(new u(f.x,f.y,f.z))}s.push({frame:m,value:l})}}if(s.length===0)return null;const n=60/i.frameRate,a=new d(r.name+"_anim","_matrix",n,d.ANIMATIONTYPE_MATRIX,i.loopMode);return a.setKeys(s),a}function _(r,i,s){const o=Z(r),t=new Y(r.name,s.skeleton,i,o),n=Q(r,s);if(n){if(!i){const a=h.RotationAxis(B.X,Math.PI/2),e=n.getKeys().map(c=>{const l=c.value.multiply(a);return{frame:c.frame,value:l}});n.setKeys(e)}t.animations.push(n)}for(const a of r.children)_(a,t,s)}function v(r,i,s){if(s.type==="ENDSITE")return;const o=K();o.time=i,o.position=new u,o.rotation=new I,s.frames.push(o);let t=0,n=0,a=0;for(let e=0;e<s.channels.length;++e){const c=r.shift();if(c)switch(s.channels[e]){case F:o.position.x=parseFloat(c.trim());break;case O:o.position.y=parseFloat(c.trim());break;case A:o.position.z=-parseFloat(c.trim());break;case k:t=x.ToRadians(+c);break;case L:n=x.ToRadians(+c);break;case P:a=x.ToRadians(+c);break;default:throw new Error("invalid channel type")}}if(n!==0||t!==0||a!==0){const e=h.Identity();h.RotationYawPitchRollToRef(n,t,a,e),o.rotation.fromRotationMatrix(e)}for(let e=0;e<s.children.length;++e)v(r,i,s.children[e])}function H(r,i,s,o){var c,m,l,f;const t=S();t.parent=s,o.list.push(t);let n=i.trim().split(/\s+/);if(n[0].toUpperCase()==="END"&&n[1].toUpperCase()==="SITE"?(t.type="ENDSITE",t.name="ENDSITE"):(t.name=n[1],t.type=n[0].toUpperCase()),((c=r.shift())==null?void 0:c.trim())!="{")throw new Error("Expected opening { after type & name");const a=(m=r.shift())==null?void 0:m.trim().split(/\s+/);if(!a)throw new Error("Unexpected end of file: missing OFFSET");if(n=a,n[0].toUpperCase()!="OFFSET")throw new Error("Expected OFFSET, but got: "+n[0]);if(n.length!=4)throw new Error("OFFSET: Invalid number of values");const e=new u(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3]));if(isNaN(e.x)||isNaN(e.y)||isNaN(e.z))throw new Error("OFFSET: Invalid values");if(t.offset=e,t.type!="ENDSITE"){if(n=(l=r.shift())==null?void 0:l.trim().split(/\s+/),!n)throw new Error("Unexpected end of file: missing CHANNELS");if(n[0].toUpperCase()!="CHANNELS")throw new Error("Expected CHANNELS definition");const p=parseInt(n[1]);t.channels=n.splice(2,p),t.children=[]}for(;r.length>0;){const p=(f=r.shift())==null?void 0:f.trim();if(p==="}")return t;p&&t.children.push(H(r,p,t,o))}throw new Error("Unexpected end of file: missing closing brace")}function C(r,i,s){const o=r.split(`
`),{loopMode:t}=s,n=new D("","",i),a=new z(n);a.loopMode=t;const e=o.shift();if(!e||e.trim().toUpperCase()!==j)throw new Error("HIERARCHY expected");const c=o.shift();if(!c)throw new Error("Unexpected end of file after HIERARCHY");const m=H(o,c.trim(),null,a),l=o.shift();if(!l||l.trim().toUpperCase()!==X)throw new Error("MOTION expected");const f=o.shift();if(!f)throw new Error("Unexpected end of file before frame count");const p=f.trim().split(/[\s]+/);if(p.length<2)throw new Error("Invalid frame count line");const E=parseInt(p[1]);if(isNaN(E))throw new Error("Failed to read number of frames.");a.numFrames=E;const R=o.shift();if(!R)throw new Error("Unexpected end of file before frame time");const T=R.trim().split(/[\s]+/);if(T.length<3)throw new Error("Invalid frame time line");const g=parseFloat(T[2]);if(isNaN(g))throw new Error("Failed to read frame time.");a.frameRate=g;for(let N=0;N<E;++N){const M=o.shift();if(!M)continue;const U=M.trim().split(/[\s]+/);v(U,N*g,m)}return a.root=m,_(a.root,null,a),a.skeleton.returnToRest(),a.skeleton}class w{constructor(i){this.name=y.name,this.extensions=y.extensions,this._loadingOptions={...w._DefaultLoadingOptions,...i??{}}}static get _DefaultLoadingOptions(){return{loopMode:d.ANIMATIONLOOPMODE_CYCLE}}createPlugin(i){return new w(i[y.name])}canDirectLoad(){return!0}importMeshAsync(i,s,o){if(typeof o!="string")return Promise.reject("BVH loader expects string data.");try{const t=C(o,s,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[t],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(t){return Promise.reject(t)}}loadAsync(i,s){return typeof s!="string"?Promise.reject("BVH loader expects string data."):this.importMeshAsync(null,i,s).then(()=>{})}loadAssetContainerAsync(i,s){if(typeof s!="string")return Promise.reject("BVH loader expects string data.");const o=new b(i);try{const t=C(s,i,this._loadingOptions);return o.skeletons.push(t),Promise.resolve(o)}catch(t){return Promise.reject(t)}}}V(new w);export{w as BVHFileLoader};
